- [1.什么是插件化](#什么是插件化)
- [2.如何调用插件中的类](#如何调用插件中的类)
- [3.如何启动插件中的四大组件](#如何启动插件中的四大组件)
- [4.如何加载插件中的资源](#如何加载插件中的资源)
- [5.如何解决冲突](#如何解决冲突)


# 什么是插件化
插件化技术最初源于免安装运行apk的想法，这个免安装的apk就可以理解为插件，而支持插件的app我们一般叫宿主。宿主可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小 了安装包的大小，另一方面可以实现app功能的动态扩展。

* 插件化解决的问题
  * APP的功能模块越来越多，体积越来越大
  * 模块之间的耦合度高，协同开发沟通成本越来越大
  * 方法数目可能超过了65535，APP占用的内存过大
  * 应用之间的互相调用 

那么只要加载了类的方法以及资源，就可以说实现了插件化

# 如何调用插件中的类
插件中的类指的是普通的java类

首先我们需要对[JAVA反射](../../JAVA/反射/JAVA反射.md)和[Android虚拟机与类加载机制](../Android虚拟机与类加载机制/Android虚拟机与类加载机制.md)有所了解，知道我们的类加载都是通过类加载器遍历Elements数组，所以调用插件中的类就是将我们插件的dexElements与宿主的dexElements合并生成新的Elements，通过反射将生成的新的Elements给到宿主的Elements
```java
public static void loadClass(Context context,String apkPath){
        try {

            //第一步. 获取宿主的dexElements
            //获取BaseDexClassLoader的pathList对象
            Class<?> clazz = Class.forName("dalvik.system.BaseDexClassLoader");
            Field pathListField = clazz.getDeclaredField("pathList");
            pathListField.setAccessible(true);

            //获取宿主的ClassLoader
            ClassLoader pathClassLoader = context.getClassLoader();
            //通过宿主的类加载器获取宿主的pathList对象
            Object hostPathList = pathListField.get(pathClassLoader);

            //获取DexPathList的dexElements
            Class<?> dexPathListClass = Class.forName("dalvik.system.DexPathList");
            Field dexElementsField = dexPathListClass.getDeclaredField("dexElements");
            dexElementsField.setAccessible(true);

            //通过dexElementsField获取宿主的dexElements
            Object[] hostDexElements = (Object[]) dexElementsField.get(hostPathList);

            //第二步. 获取插件的dexElements
            //获取插件的ClassLoader，如果使用PathClassLoader需要的apkPath就是dex路径，DexClassLoader传入的是apk路径
            ClassLoader dexClassLoader = new DexClassLoader(apkPath, context.getCacheDir().getAbsolutePath(),
                    null, pathClassLoader);

            //通过插件的类加载器获取宿主的pathList对象
            Object pluginPathList = pathListField.get(dexClassLoader);
            //通过dexElementsField获取插件的dexElements
            Object[] pluginDexElements = (Object[]) dexElementsField.get(pluginPathList);

            //第三步. 合并宿主和插件的dexElements
            // 创建一个新数组，类型就是宿主或者插件dexElements的类型，大小就是两个的合
            Object[] newDexElements = (Object[]) Array.newInstance(hostDexElements.getClass().getComponentType(),
                    hostDexElements.length + pluginDexElements.length);

            //将宿主的dexElements拷贝到新数组中
            System.arraycopy(hostDexElements, 0, newDexElements,
                    0, hostDexElements.length);

            //将插件的dexElements拷贝到新数组中
            System.arraycopy(pluginDexElements, 0, newDexElements,
                    hostDexElements.length, pluginDexElements.length);

            //第四步. 将新数组赋值到宿主的dexElements
            dexElementsField.set(hostPathList, newDexElements);

        } catch (Exception e) {
            e.printStackTrace();
        }
}
```
这时候将插件生成apk同时保存到手机中，宿主app就可以通过调用上面的方法加载插件的类，然后通过反射就可以使用插件中的方法了

# 如何启动插件中的四大组件
我们以一个没有界面的Activity为例，当然这个Activity还不能加载任何xml

那如何启动呢？最大的问题就是绕过注册文件，因为加载一个Activity的时候AMS会去验证清单文件中是否注册，所以具体思想如下图
![image](https://user-images.githubusercontent.com/61224872/113690743-4e08ef00-96fe-11eb-87c3-92c62760d5d9.png)
通过[动态代理](.doc/设计模式/代理模式.md)和[反射](.doc/JAVA/反射/JAVA反射.md)实现
```java
//我们首先将宿主中的代理ProxyActivity在清单文件中进行注册
<activity android:name=".ProxyActivity" />
```
下一步我们就可以在通过调用启动插件Activity的时候，将Intent中插件的Activity替换为宿主的代理Activity
```java

```









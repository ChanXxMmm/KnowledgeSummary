- [1.什么是插件化](#什么是插件化)
- [2.如何调用插件中的类](#如何调用插件中的类)
- [3.如何启动插件中的四大组件](#如何启动插件中的四大组件)
- [4.如何加载插件中的资源](#如何加载插件中的资源)
- [5.如何解决冲突](#如何解决冲突)


# 什么是插件化
插件化技术最初源于免安装运行apk的想法，这个免安装的apk就可以理解为插件，而支持插件的app我们一般叫宿主。宿主可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小 了安装包的大小，另一方面可以实现app功能的动态扩展。

* 插件化解决的问题
  * APP的功能模块越来越多，体积越来越大
  * 模块之间的耦合度高，协同开发沟通成本越来越大
  * 方法数目可能超过了65535，APP占用的内存过大
  * 应用之间的互相调用 

那么只要加载了类的方法以及资源，就可以说实现了插件化

# 如何调用插件中的类
插件中的类指的是普通的java类

首先我们需要对[反射](.doc/JAVA/反射/JAVA反射.md)和[类加载机制](../Android虚拟机与类加载机制/Android虚拟机与类加载机制.md)有所了解，知道我们的类加载都是通过类加载器遍历Elements数组，所以调用插件中的类就是将我们插件的dexElements与宿主的dexElements合并生成新的Elements，通过反射将生成的新的Elements给到宿主的Elements
```java
public static void loadClass(Context context,String apkPath){
        try {

            //第一步. 获取宿主的dexElements
            //获取BaseDexClassLoader的pathList对象
            Class<?> clazz = Class.forName("dalvik.system.BaseDexClassLoader");
            Field pathListField = clazz.getDeclaredField("pathList");
            pathListField.setAccessible(true);

            //获取宿主的ClassLoader
            ClassLoader pathClassLoader = context.getClassLoader();
            //通过宿主的类加载器获取宿主的pathList对象
            Object hostPathList = pathListField.get(pathClassLoader);

            //获取DexPathList的dexElements
            Class<?> dexPathListClass = Class.forName("dalvik.system.DexPathList");
            Field dexElementsField = dexPathListClass.getDeclaredField("dexElements");
            dexElementsField.setAccessible(true);

            //通过dexElementsField获取宿主的dexElements
            Object[] hostDexElements = (Object[]) dexElementsField.get(hostPathList);

            //第二步. 获取插件的dexElements
            //获取插件的ClassLoader，如果使用PathClassLoader需要的apkPath就是dex路径，DexClassLoader传入的是apk路径
            ClassLoader dexClassLoader = new DexClassLoader(apkPath, context.getCacheDir().getAbsolutePath(),
                    null, pathClassLoader);

            //通过插件的类加载器获取宿主的pathList对象
            Object pluginPathList = pathListField.get(dexClassLoader);
            //通过dexElementsField获取插件的dexElements
            Object[] pluginDexElements = (Object[]) dexElementsField.get(pluginPathList);

            //第三步. 合并宿主和插件的dexElements
            // 创建一个新数组，类型就是宿主或者插件dexElements的类型，大小就是两个的合
            Object[] newDexElements = (Object[]) Array.newInstance(hostDexElements.getClass().getComponentType(),
                    hostDexElements.length + pluginDexElements.length);

            //将宿主的dexElements拷贝到新数组中
            System.arraycopy(hostDexElements, 0, newDexElements,
                    0, hostDexElements.length);

            //将插件的dexElements拷贝到新数组中
            System.arraycopy(pluginDexElements, 0, newDexElements,
                    hostDexElements.length, pluginDexElements.length);

            //第四步. 将新数组赋值到宿主的dexElements
            dexElementsField.set(hostPathList, newDexElements);

        } catch (Exception e) {
            e.printStackTrace();
        }
}
```
这时候将插件生成apk同时保存到手机中，宿主app就可以通过调用上面的方法加载插件的类，然后通过反射就可以使用插件中的方法了

# 如何启动插件中的四大组件











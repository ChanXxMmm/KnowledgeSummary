- [1.什么是插件化](#什么是插件化)
- [2.如何调用插件中的类](#如何调用插件中的类)
- [3.如何启动插件中的四大组件](#如何启动插件中的四大组件)
- [4.如何加载插件中的资源](#如何加载插件中的资源)
- [5.如何解决冲突](#如何解决冲突)


# 什么是插件化
插件化技术最初源于免安装运行apk的想法，这个免安装的apk就可以理解为插件，而支持插件的app我们一般叫宿主。宿主可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小 了安装包的大小，另一方面可以实现app功能的动态扩展。

* 插件化解决的问题
  * APP的功能模块越来越多，体积越来越大
  * 模块之间的耦合度高，协同开发沟通成本越来越大
  * 方法数目可能超过了65535，APP占用的内存过大
  * 应用之间的互相调用 

那么只要加载了类的方法以及资源，就可以说实现了插件化

# 如何调用插件中的类
插件中的类指的是普通的java类

首先我们需要对[JAVA反射](../../JAVA/反射/JAVA反射.md)和[Android虚拟机与类加载机制](../Android虚拟机与类加载机制/Android虚拟机与类加载机制.md)有所了解，知道我们的类加载都是通过类加载器遍历Elements数组，所以调用插件中的类就是将我们插件的dexElements与宿主的dexElements合并生成新的Elements，通过反射将生成的新的Elements给到宿主的Elements
```java
public static void loadClass(Context context,String apkPath){
        try {

            //第一步. 获取宿主的dexElements
            //获取BaseDexClassLoader的pathList对象
            Class<?> clazz = Class.forName("dalvik.system.BaseDexClassLoader");
            Field pathListField = clazz.getDeclaredField("pathList");
            pathListField.setAccessible(true);

            //获取宿主的ClassLoader
            ClassLoader pathClassLoader = context.getClassLoader();
            //通过宿主的类加载器获取宿主的pathList对象
            Object hostPathList = pathListField.get(pathClassLoader);

            //获取DexPathList的dexElements
            Class<?> dexPathListClass = Class.forName("dalvik.system.DexPathList");
            Field dexElementsField = dexPathListClass.getDeclaredField("dexElements");
            dexElementsField.setAccessible(true);

            //通过dexElementsField获取宿主的dexElements
            Object[] hostDexElements = (Object[]) dexElementsField.get(hostPathList);

            //第二步. 获取插件的dexElements
            //获取插件的ClassLoader，如果使用PathClassLoader需要的apkPath就是dex路径，DexClassLoader传入的是apk路径
            ClassLoader dexClassLoader = new DexClassLoader(apkPath, context.getCacheDir().getAbsolutePath(),
                    null, pathClassLoader);

            //通过插件的类加载器获取宿主的pathList对象
            Object pluginPathList = pathListField.get(dexClassLoader);
            //通过dexElementsField获取插件的dexElements
            Object[] pluginDexElements = (Object[]) dexElementsField.get(pluginPathList);

            //第三步. 合并宿主和插件的dexElements
            // 创建一个新数组，类型就是宿主或者插件dexElements的类型，大小就是两个的合
            Object[] newDexElements = (Object[]) Array.newInstance(hostDexElements.getClass().getComponentType(),
                    hostDexElements.length + pluginDexElements.length);

            //将宿主的dexElements拷贝到新数组中
            System.arraycopy(hostDexElements, 0, newDexElements,
                    0, hostDexElements.length);

            //将插件的dexElements拷贝到新数组中
            System.arraycopy(pluginDexElements, 0, newDexElements,
                    hostDexElements.length, pluginDexElements.length);

            //第四步. 将新数组赋值到宿主的dexElements
            dexElementsField.set(hostPathList, newDexElements);

        } catch (Exception e) {
            e.printStackTrace();
        }
}
```
这时候将插件生成apk同时保存到手机中，宿主app就可以通过调用上面的方法加载插件的类，然后通过反射就可以使用插件中的方法了

# 如何启动插件中的四大组件
我们以一个没有界面的Activity为例，当然这个Activity还不能加载任何xml

那如何启动呢？最大的问题就是绕过注册文件，因为加载一个Activity的时候AMS会去验证清单文件中是否注册，所以具体思想如下图
![image](https://user-images.githubusercontent.com/61224872/113690743-4e08ef00-96fe-11eb-87c3-92c62760d5d9.png)
通过[代理模式](../../设计模式/代理模式.md)和[JAVA反射](../../JAVA/反射/JAVA反射.md)实现
```java
//我们首先将宿主中的代理ProxyActivity在清单文件中进行注册
<activity android:name=".ProxyActivity" />
```
下一步我们就可以在通过调用启动插件Activity的时候，将Intent中插件的Activity替换为宿主的代理Activity
```java
ActivityTaskManager.getService().startActivity(whoThread,
                    who.getBasePackageName(), who.getAttributionTag(), intent,
                    intent.resolveTypeIfNeeded(who.getContentResolver()), token,
                    target != null ? target.mEmbeddedID : null, requestCode, 0, null, options);
                    
 public static IActivityTaskManager getService() {
        return IActivityTaskManagerSingleton.get();
 }

 @UnsupportedAppUsage(trackingBug = 129726065)
 private static final Singleton<IActivityTaskManager> IActivityTaskManagerSingleton =
         new Singleton<IActivityTaskManager>() {
             @Override
             protected IActivityTaskManager create() {
                 final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
                 return IActivityTaskManager.Stub.asInterface(b);
             }
};
public abstract class Singleton<T> {
    private T mInstance;

    protected abstract T create();

    public final T get() {
        synchronized (this) {
            if (mInstance == null) {
                mInstance = create();
            }
            return mInstance;
        }
    }
}
```
我们可以看到我们只需要代理IActivityTaskManager即可，而IActivityTaskManager就是Singleton的mIntance，所以我们通过修改Singleton的mIntance为我们的动态代理对象，然后修改intent即可
```java
private static final String TARGET_INTENT = "target_intent";
public static void hookAMS() {
        try {
            // 获取 singleton 对象
            Field singletonField = null;
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { // 小于8.0
                Class<?> clazz = Class.forName("android.app.ActivityManagerNative");
                singletonField = clazz.getDeclaredField("gDefault");
            } else {
                Class<?> clazz = Class.forName("android.app.ActivityManager");
                singletonField = clazz.getDeclaredField("IActivityManagerSingleton");
            }
            singletonField.setAccessible(true);
            Object singleton = singletonField.get(null);

            // 获取 系统的 IActivityManager 对象
            Class<?> singletonClass = Class.forName("android.util.Singleton");
            Field mInstanceField = singletonClass.getDeclaredField("mInstance");
            mInstanceField.setAccessible(true);
            final Object mInstance = mInstanceField.get(singleton);

            Class<?> iActivityManagerClass = Class.forName("android.app.IActivityManager");

            // 创建动态代理对象
            Object proxyInstance = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
                    new Class[]{iActivityManagerClass}, new InvocationHandler() {
                        @Override
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                            // 过滤
                            if ("startActivity".equals(method.getName())) {
                                int index = -1;

                                for (int i = 0; i < args.length; i++) {
                                    if (args[i] instanceof Intent) {
                                        index = i;
                                        break;
                                    }
                                }
                                // 启动插件的
                                Intent intent = (Intent) args[index];

                                Intent proxyIntent = new Intent();
                                proxyIntent.setClassName("com.enjoy.leo_plugin",
                                        "com.enjoy.leo_plugin.ProxyActivity");

                                proxyIntent.putExtra(TARGET_INTENT, intent);

                                args[index] = proxyIntent;
                            }

                            // args  method需要的参数  --- 不改变原有的执行流程
                            // mInstance 系统的 IActivityManager 对象
                            return method.invoke(mInstance, args);
                        }
                    });

            // ActivityManager.getService() 替换成 proxyInstance
            mInstanceField.set(singleton, proxyInstance);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```
这个时候我们就成功替换了Intent，之后我们要在AMS校验完去再次替换intent
```java
 public void handleMessage(Message msg) {
            if (DEBUG_MESSAGES) Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, "LAUNCH_ACTIVITY");
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;
                ///...
}

final H mH = new H();

public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
```
我们可以看到通过AMS校验完后启动Activity会去H的Handler发送一个消息，我们的intent就存在了ActivityClientRecord中，也就是msg.obj。同时这个Handler没有创建callback，所以我们要做的就是创建一个回调，优先拦截处理handleMessage，以此来改变intent
```java
public static void hookHandler() {
        try {
            // 获取 ActivityThread 类的 Class 对象
            Class<?> clazz = Class.forName("android.app.ActivityThread");

            // 获取 ActivityThread 对象
            Field activityThreadField = clazz.getDeclaredField("sCurrentActivityThread");
            activityThreadField.setAccessible(true);
            Object activityThread = activityThreadField.get(null);

            // 获取 mH 对象
            Field mHField = clazz.getDeclaredField("mH");
            mHField.setAccessible(true);
            final Handler mH = (Handler) mHField.get(activityThread);

            Field mCallbackField = Handler.class.getDeclaredField("mCallback");
            mCallbackField.setAccessible(true);

            // 创建的callback
            Handler.Callback callback = new Handler.Callback() {

                @Override
                public boolean handleMessage(@NonNull Message msg) {
                    // 通过msg  可以拿到 Intent，可以换回执行插件的Intent
                    // msg.obj == ActivityClientRecord
                    switch (msg.what) {
                        case 100:
                            try {
                                Field intentField = msg.obj.getClass().getDeclaredField("intent");
                                intentField.setAccessible(true);
                                // 启动代理Intent
                                Intent proxyIntent = (Intent) intentField.get(msg.obj);
                                // 启动插件Intent
                                Intent intent = proxyIntent.getParcelableExtra(TARGET_INTENT);
                                if (intent != null) {
                                    intentField.set(msg.obj, intent);
                                }
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                            break;
                        case 159://9.0以上
                            try {
                                // 获取 mActivityCallbacks 对象
                                Field mActivityCallbacksField = msg.obj.getClass()
                                        .getDeclaredField("mActivityCallbacks");

                                mActivityCallbacksField.setAccessible(true);
                                List mActivityCallbacks = (List) mActivityCallbacksField.get(msg.obj);

                                for (int i = 0; i < mActivityCallbacks.size(); i++) {
                                    if (mActivityCallbacks.get(i).getClass().getName()
                                            .equals("android.app.servertransaction.LaunchActivityItem")) {
                                        Object launchActivityItem = mActivityCallbacks.get(i);

                                        // 获取启动代理的 Intent
                                        Field mIntentField = launchActivityItem.getClass()
                                                .getDeclaredField("mIntent");
                                        mIntentField.setAccessible(true);
                                        Intent proxyIntent = (Intent) mIntentField.get(launchActivityItem);

                                        // 目标 intent 替换 proxyIntent
                                        Intent intent = proxyIntent.getParcelableExtra(TARGET_INTENT);
                                        if (intent != null) {
                                            mIntentField.set(launchActivityItem, intent);
                                        }
                                    }
                                }
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                            break;
                    }
                    // 必须 return false
                    return false;
                }
            };

            // 替换系统的 callBack
            mCallbackField.set(mH, callback);
        } catch (Exception e) {
            e.printStackTrace();
        }
}
```
这个时候我们就成功替换了ProxyActivity为我们的插件Activity

# 如何加载插件中的资源
我们主要加载的就是assets和res
```java
//加载res
String appName = getResources().getString(R.string.app_name);

//加载assets
InputStream is = getAssets().open("icon_1.png");
```
如果我们走进源码就会发现都是去通过AssetManager类来访问哪些被编译过的应用程序资源文件的，不过getResources在访问之前，它会先根据资源ID查找得到对应的资源文件名，而Assetmanager对象即可以通过文件名访问那些被编译过得，也可以访问没有被编译过得应用程序资源文件。

* raw文件夹和assets文件夹的区别
  * raw: Android会自动为这目录中的所有资源文件生成一个ID，这意味着很容易就可以访问到这个资源，甚至在xm中都是可以访问的，使用ID访问速度是最快的
  * assets: 不会生成ID，只能通过AssetManager访问，xml中不能访问，访问速度会慢些，不过操作更加方便

我们可以知道getResources().getString的时候是通过AssetManager，那getResources()肯定是在Context内部，所以我们去看下AssetManager是怎么绑定Context的，我们看下Application创建的时候
```java
//ActivityThread.handleLauncherActivity
Activity a = performLaunchActivity(r, customIntent)

//ActivityThread.performLaunchActivity
ContextImpl appContext = createBaseContextForActivity(r);

//ActivityThread.createBaseContextForActivity
ContextImpl appContext = ContextImpl.createActivityContext(
                this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);

//ContextImpl.createActivityContext
//此时创建出Context
ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName,
                activityToken, null, 0, classLoader);
context.setResources(resourcesManager.createBaseActivityResources(activityToken,
                packageInfo.getResDir(),
                splitDirs,
                packageInfo.getOverlayDirs(),
                packageInfo.getApplicationInfo().sharedLibraryFiles,
                displayId,
                overrideConfiguration,
                compatInfo,
                classLoader));
                
//可以看到上面是将资源给到Context，我们走进去看下
//ResourcesManager.createBaseActivityResources
//可以看到将资源路径和其他包装成ResourcesKey
final ResourcesKey key = new ResourcesKey(
                    resDir,
                    splitResDirs,
                    overlayDirs,
                    libDirs,
                    displayId,
                    overrideConfig != null ? new Configuration(overrideConfig) : null, // Copy
                    compatInfo);
return getOrCreateResources(activityToken, key, classLoader);

//ResourcesManager.getOrCreateResources
ResourcesImpl resourcesImpl = createResourcesImpl(key);

//上面创建Resources，我们可以走进去看下
//ResourcesManager.createResourcesImpl
//创建AssetManager，并将AssetManager与Resources进行绑定
final AssetManager assets = createAssetManager(key);
final ResourcesImpl impl = new ResourcesImpl(assets, dm, config, daj);

//ResourcesManager.createAssetManager
//AssetManager内部有个存储资源的容器，所以就是将资源目录的内容添加到容器中，所以我们调用资源就是从容器中拿
builder.addAssetPath(key.mResDir);
                        
```
从上面可以看到，AssetManager与Resources进行绑定，以及我们的资源是存在AssetManager内部的容器中，与我们之前说的宿主的类存在数组中是一个意思，所以我们加载插件的资源的实现思想就是将我们插件的资源通过AssetManager.addAssetPath(插件资源)就可以

此时有两套方案：
* 插件资源和宿主资源合并： 会有资源冲突问题，比如0x7f0a000a
  * 无论是哪个apk，包的id都是7f开头
  * 后面的0a就是资源类型id，从01不断往上++
  * 000a就是同一类型下id，从0000不断往上++
* 专门创建一个AssetManager加载插件的资源

我们先看来看第二种方案：专门创建一个AssetManager加载插件的资源
```java

```






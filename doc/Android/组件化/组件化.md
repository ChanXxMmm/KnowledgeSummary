- [1.什么是组件化](#什么是组件化)
- [2.如何实现不同业务间跳转](#如何实现不同业务间跳转)
- [3.APT](#APT)
- [3.手写类似Arouter](#手写类似Arouter)
- [3.Arouter](#Arouter)

# 什么是组件化
个人理解： 拆分业务，降低耦合，自由拆卸，独立运行

所以不同业务的module之间不能直接通讯，也不能循环依赖

# 如何实现不同业务间跳转
1. 使用EventBus，但是维护成本高，不好管理
2. 使用广播，但是不好管理，都统一发送了
3. 使用隐式跳转，但是注册文件中配置的xml太多
4. 类加载方式，但是容易包名类名写错，相对来说还好
5. 使用全局MAP，但是要注册很多对象

比如现在有两个业务module，它们内部有两个界面A和B，现在要实现A跳转到B

* 针对方式4上代码:
```java
try{
  Class targetClass = Class.forName("com.xxx.modulea.A");
  Intent intent = new Intent(A.this,targetClass);
  startActivity(intent);
}catch(ClassNotFoundException e){}
```
* 针对方式5，需要在业务层下面的基础库中增加一个全局Map，将所有Activity注册进来
```java
//创建一个Path的Bean，存储path和对应的class
public class PathBean{
  private String path;
  private Class clazz;
  
  public PathBean(String path,Class clazz){
    this.path = path;
    this.clazz = clazz;
  }
  
   //省略get和set方法
}

//我们通过path管理器来管理全局的map
public class RecordPathManager{
  //由于不同业务module下可能有多个Activity，所以根据组名保存
  private static Map<String,List<PathBean>> maps = new HashMap<>();
  
  //将Activity注册到全局Map中
  public static void addGroupInfo(String groupName,String path,Class<?> clazz){
    List<PathBean> list = maps.get(groupName);
    
    if(null = list){
      list = new ArrayList<>();
      list.add(new PathBean(path,clazz));
      maps.put(groutName,list);
    }else{
      maps.put(groutName,list);
    }
  }
}

//根据组名和路径得到Class
public static Class<?> startTargetActivity(String groupName,String pathName){
   List<PathBean> list = maps.get(groupName);
    if(null = list){
      return null;
    }
    for (PathBean pathBean : list){
      if(pathName.equalsIgnoreCase(pathBean.getPath())){
        return pathBean.getClazz();
      }
    }
}
```
在Application中将所有Activity注册到Map中，使用时直接通过管理器获取即可，但是问题也和明显，需要在Application中全部注册

# APT
注解处理器--通过注解生成我们的代码

在早期的EnventBus中就是一行一行的写，先写包，在写类，最后写方法，可读性强

后期转换为通过JavaPoet来实现，Arouter，dagger2等也都是这么实现的，而Javapoet是先写方法，后写类，最后写包，oop思维，但是要倒序写，可读性不强

# 手写类似Arouter
针对上面的全局Map，Arouter应运而生，其内部也是差不多有个Map来存储，我们可以理解为路由表，但是我们怎么避免手动去注册呢？所以此时我们要用到APT技术，在编译的时候就将Activity注册到路由表中

通过ATP+JavaPoet开撸:
1. 首先创建一个我们用于声明注解的Module(JAVA)和我们对应的注解
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface MyARouter {
  String path();
  String group() default "";
}
```
之后我们就通过这个注解找到需要注册到路由表的Activity

2. 创建一个我们的Module--compiler(JAVA)和修改其gradle，用于通过ATP+JavaPoet在编译期间寻找我们的注解将对应的Activity注册到路由表中，也就是说这个Module就是我们的注解处理器
```java
//ArouterProcessor.java
@AutoService(Processor.class)//启动服务
@SupportedAnnotationTypes("cn.xxx.my_annotations.MyArouter")//指明注解处理器注册哪一个注解
@SupportedSourceVersion(SourceVersion.RELEASE_7)//环境版本
public class ArouterProcessor extends AbstractProcessor {

    //操作Element的工具(类，函数，属性都是Element)
    private Elements elementTool;

    //type(类信息)的工具类
    private Types typeTool;

    //由于我们这个是java工程，所以打印日志要用Messager
    private Messager messager;

    //文件生成器
    private Filer filer;

    //初始化
    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);

        elementTool = processingEnvironment.getElementUtils();
        messager = processingEnvironment.getMessager();
        filer = processingEnvironment.getFiler();
    }

    //在编译期间回调
    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        return false;
    }
}
```
这时候我们的注解处理器还需要拿到主项目中编译时的信息，我们在主工程的grale中defaultConfig中进行配置同时使用我们自己的注解器
```java
javaCompileOptions {
            annotationProcessorOptions {
                arguments = [woshishui: 'nihao']
            }
}

//app/gralde中
annotationProcessor project(":compiler")
```
这时候我们就可以在我们的注解处理器中增加一个注解来拿到这个参数
```java
@SupportedOptions("woshishui")
```
我们可以在注解处理器初始化方法中通过roundEnvironment获取到这个配置

这时候相当于我们用自己的注解处理器与主项目可以通讯，那么现在我们需要拿到主项目中的所有类来遍历我们的注解去生成简单地路由类
```java
//动态生成该类，同时类名中的MainActivity也是根据不同类名生成对应的
public class MainActivity$$$$$ARouter {

  public static Class findTargetClass (String path){
    路径中的/app/MainActivity也是根据注解中的不同配置进行生成，后面的MainActivity.class也是动态改变
    return path.equals("/app/MainActivity")? MainActivity.class:null;
  }
}
```
上面就是我们需要通过APT生成的代码，现在我们看看怎么实现自动生成对应代码
```java
@AutoService(Processor.class)//启动服务
@SupportedAnnotationTypes("cn.xxx.my_annotations.MyARouter")//指明注解处理器注册哪一个注解
@SupportedSourceVersion(SourceVersion.RELEASE_7)//环境版本
@SupportedOptions("hi")
public class ArouterProcessor extends AbstractProcessor {

    //操作Element的工具(类，函数，属性都是Element)
    private Elements elementTool;

    //type(类信息)的工具类
    private Types typeTool;

    //由于我们这个是java工程，所以打印日志要用Messager
    private Messager messager;

    //文件生成器
    private Filer filer;

    //初始化
    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);

        elementTool = processingEnvironment.getElementUtils();
        messager = processingEnvironment.getMessager();
        filer = processingEnvironment.getFiler();

        String value = processingEnvironment.getOptions().get("hi");
        messager.printMessage(Diagnostic.Kind.NOTE,">>>>>>>>>>>>>>>>>>>>>> options:"+value);
    }



    //在编译期间回调
    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {

        if (set.isEmpty()) return false;

        //获取被MyArouter注解的类节点信息
        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(MyARouter.class);

        //多个地方使用，所以进行遍历，根据不同的类，生成不同的类
        for (Element element : elements) {

            //拿到类所对应的包名，后面会用到
            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();

            //上面的模板方法，我们先创建类名，后面会用到
            String className = element.getSimpleName().toString();

            messager.printMessage(Diagnostic.Kind.NOTE,"被@MyARouter注解的类："+className);

            String findClassName = className +"$$$$$ARouter";

            //拿到我们的注解
            MyARouter myARouter = element.getAnnotation(MyARouter.class);

            //我们之前说过，通过JavaPoat是倒序,所以我们从方法开始
            //1. 方法
            //通过MethodSpec构造者创建方法
            MethodSpec findTargetClass = MethodSpec.methodBuilder("findTargetClass")
                    //创建方法的public static
                    .addModifiers(Modifier.PUBLIC,Modifier.STATIC)
                    //创建参数返回值
                    .returns(Class.class)
                    //创建参数
                    .addParameter(String.class,"path")
                    //创建方法中的内容
                    .addStatement("return path.equals($S) ? $T.class : null",myARouter.path(), ClassName.get((TypeElement) element))
                    .build();

            //2. 类
            TypeSpec myClass = TypeSpec.classBuilder(findClassName)
                    //将方法给到这个类
                    .addMethod(findTargetClass)
                    .addModifiers(Modifier.PUBLIC)
                    .build();

            //3. 包
            JavaFile packagef = JavaFile.builder(packageName,myClass).build();

            //4. 生成文件
            try {
                packagef.writeTo(filer);
            } catch (IOException e) {
                e.printStackTrace();
                messager.printMessage(Diagnostic.Kind.NOTE,"生成"+findClassName+"时失败，异常："+e.toString());
            }
        }

        return true;
    }
}
```
此时我们编译后，可以在主项目中的build中看到该文件，这样我们就可以通过生成的这个文件直接找到MainActivity

但是我们可以发现，这么做没有很好的扩展性和可管理型，所以此时我们将path拆分成group和path两个模板，首先我们先定义group和path的两个接口，用于接口下沉，上层通过接口访问
```java
//
public interface ARouterGroup {

    Map<String, Class<? extends ARouterPath>> getGroupMap();
}

public interface ARouterPath {

    Map<String, RouterBean> getPathMap();
}

public class RouterBean {
    // 为了以后的发展
    public enum TypeEnum {
        ACTIVITY
    }
    private TypeEnum typeEnum; // 枚举类型：Activity
    private Element element; // 类节点 JavaPoet学习的时候，可以拿到很多的信息
    private Class<?> myClass; // 被注解的 Class对象
    private String path; // 路由地址  
    private String group; // 路由组 
    
    // 对外暴露
    // 对外提供简易版构造方法，主要是为了方便APT生成代码
    public static RouterBean create(TypeEnum type, Class<?> clazz, String path, String group) {
        return new RouterBean(type, clazz, path, group);
    }
    
    //...省略构造，get和set方法
}
```
此时我们就可以通过上面的两个接口来看下我们需要通过APT生成的group和path的模板长什么样子
```java
public class ARouter$$Group$$组名 implements ARouterGroup {
  @Override
  public Map<String,Class<? extends ARouterPath>> getGroupMap(){
    Map<String,Class<? extends ARouterPath>> groupMap = new HashMap<>();
    groupMap.put(组名,ARouter$$Path$$组名.class);
    return groupMap;
  }
}

public class ARouter$$Path$$组名 implements ARouterPath {
  @Override
  public Map<String,RouterBean> getPathMap(){
    Map<String,Class<? extends ARouterPath>> pathMap = new HashMap<>();
    pathMap.put(注解中的path,RouterBean);
    return pathMap;
  }
}
```
我们可以看到，我们会对每个module业务生成不同的group和其内部不同类的path，此时我们来通过APT实现下生成，同时增加一些校验工作
```java
//在我们的不同业务module中的grale中更改配置，那个module用到了就要增加此配置
 javaCompileOptions {
            annotationProcessorOptions {
                //moduleName就是module名字，packageNameForAPT就是我们对应的包名
                arguments = [moduleName: project.getName(), packageNameForAPT: 'cn.xxx']
            }
}

//ArouterProcessor
@AutoService(Processor.class)//启动服务
@SupportedAnnotationTypes("cn.xxx.my_annotations.MyARouter")//指明注解处理器注册哪一个注解
@SupportedSourceVersion(SourceVersion.RELEASE_7)//环境版本
@SupportedOptions({"moduleName", "packageNameForAPT"})
public class ArouterProcessor extends AbstractProcessor {

    //操作Element的工具(类，函数，属性都是Element)
    private Elements elementTool;

    //type(类信息)的工具类
    private Types typeTool;

    //由于我们这个是java工程，所以打印日志要用Messager
    private Messager messager;

    //文件生成器
    private Filer filer;

    private String options; // 各个模块传递过来的模块名
    private String aptPackage; // 各个模块传递过来的目录 用于统一存放 apt生成的文件

    //path的map
    private Map<String, List<RouterBean>> mAllPathMap = new HashMap<>();

    //group的map
    private Map<String, String> mAllGroupMap = new HashMap<>();
    //初始化
    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);

        elementTool = processingEnvironment.getElementUtils();
        messager = processingEnvironment.getMessager();
        filer = processingEnvironment.getFiler();
        typeTool = processingEnvironment.getTypeUtils();

        options = processingEnvironment.getOptions().get("moduleName");
        aptPackage = processingEnvironment.getOptions().get("packageNameForAPT");

//        String value = processingEnvironment.getOptions().get("hi");
        messager.printMessage(Diagnostic.Kind.NOTE,">>>>>>>>>>>>>>>>>>>>>> "+options+"==="+aptPackage);
    }

    //在编译期间回调
    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {

        if (set.isEmpty()) return false;

        //获取被MyArouter注解的类节点信息
        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(MyARouter.class);
        // 通过Element工具类，获取Activity，Callback类型
        TypeElement activityType = elementTool.getTypeElement("android.app.Activity");
        // 显示类信息（获取被注解的节点，类节点）这也叫自描述 Mirror
        TypeMirror activityMirror = activityType.asType();
        //多个地方使用，所以进行遍历，根据不同的类，生成不同的类
        for (Element element : elements) {

            //拿到类所对应的包名，后面会用到
            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();
            //上面的模板方法，我们先创建类名，后面会用到
            String className = element.getSimpleName().toString();

            messager.printMessage(Diagnostic.Kind.NOTE,"被@MyARouter注解的类："+className);

            String findClassName = className +"$$$$$ARouter";

            //拿到我们的注解
            MyARouter myARouter = element.getAnnotation(MyARouter.class);

            //创建RouterBean
            RouterBean routerBean = new RouterBean.Builder()
                    .addGroup(myARouter.group())
                    .addPath(myARouter.path())
                    .addElement(element)
                    .build();

            // MyARouter注解的类 必须继承 Activity
            TypeMirror elementMirror = element.asType();
            if (typeTool.isSubtype(elementMirror, activityMirror)) { // activityMirror  android.app.Activity描述信息
                routerBean.setTypeEnum(RouterBean.TypeEnum.ACTIVITY); // 最终证明是 Activity
            } else {
                // 不匹配抛出异常
                throw new RuntimeException("@MyARouter注解目前仅限用于Activity类之上");
            }

            //校验routerBean
            if (checkRouterPath(routerBean)){
                messager.printMessage(Diagnostic.Kind.NOTE,"校验成功");
                List<RouterBean> routerBeans = mAllPathMap.get(routerBean.getGroup());

                // 如果从Map中找不到key为：bean.getGroup()的数据，就新建List集合再添加进Map
                if (routerBeans==null||routerBeans.size()==0) { // path仓库没有东西
                    routerBeans = new ArrayList<>();
                    routerBeans.add(routerBean);
                    mAllPathMap.put(routerBean.getGroup(), routerBeans);// 加入path仓库
                } else {
                    routerBeans.add(routerBean);
                }
            }else { // ERROR 编译期发生异常
                messager.printMessage(Diagnostic.Kind.ERROR, "@MyARouter注解未按规范配置，如：/app/MainActivity");
            }

            //获取到我们之前定义的两个接口的描述
            TypeElement pathType = elementTool.getTypeElement("cn.xxx.ARouterPath"); // ARouterPath描述
            TypeElement groupType = elementTool.getTypeElement("cn.xxx.ARouterGroup"); // ARouterGroup描述

            //该创建group和path的类了，我们肯定是先生成path
            try {
                createPathFile(pathType); // 生成 Path类
            } catch (IOException e) {
                e.printStackTrace();
                messager.printMessage(Diagnostic.Kind.NOTE, "在生成PATH模板时，异常了 e:" + e.getMessage());

            }

            //生成group
            try {
                createGroupFile(groupType, pathType);
            } catch (IOException e) {
                e.printStackTrace();
                messager.printMessage(Diagnostic.Kind.NOTE, "在生成GROUP模板时，异常了 e:" + e.getMessage());
            }
        }

        return true;
    }

    //生成 Path类
    private void createPathFile(TypeElement pathType) throws IOException {
        // 判断 map仓库中，是否有需要生成的文件
        if (mAllPathMap==null||mAllPathMap.size()==0) {
            return;
        }

        //构建方法的返回类型Map<String, RouterBean>
        TypeName methodReturn = ParameterizedTypeName.get(
                ClassName.get(Map.class),         // Map
                ClassName.get(String.class),      // Map<String,
                ClassName.get(RouterBean.class)   // Map<String, RouterBean>
        );

        for (Map.Entry<String, List<RouterBean>> entry : mAllPathMap.entrySet()) {
            //1. 方法
            MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("getPathMap")
                    .addAnnotation(Override.class) // 给方法上添加注解  @Override
                    .addModifiers(Modifier.PUBLIC) // public修饰符
                    .returns(methodReturn); // 把Map<String, RouterBean> 加入方法返回

            // Map<String, RouterBean> pathMap = new HashMap<>(); // $N == 变量 为什么是这个，因为变量有引用 所以是$N
            methodBuilder.addStatement("$T<$T, $T> $N = new $T<>()",
                    ClassName.get(Map.class),           // Map
                    ClassName.get(String.class),        // Map<String,
                    ClassName.get(RouterBean.class),    // Map<String, RouterBean>
                    "pathMap",                          // Map<String, RouterBean> pathMap
                    ClassName.get(HashMap.class)        // Map<String, RouterBean> pathMap = new HashMap<>();
            );

            List<RouterBean> pathList = entry.getValue();
            //由于一个组中可能有多个RouterBean，一个RouterBean对应一个Activity
            for (RouterBean bean : pathList) {
                methodBuilder.addStatement("$N.put($S, $T.create($T.$L, $T.class, $S, $S))",
                        "pathMap", // pathMap.put
                        bean.getPath(),
                        ClassName.get(RouterBean.class), // RouterBean
                        ClassName.get(RouterBean.TypeEnum.class), // RouterBean.Type
                        bean.getTypeEnum(), // 枚举类型：ACTIVITY
                        ClassName.get((TypeElement) bean.getElement()), // MainActivity.class Main2Activity.class
                        bean.getPath(), // 路径名
                        bean.getGroup() // 组名
                );
            }

            //返回值
            methodBuilder.addStatement("return $N", "pathMap");

            //2. 因为这里面有implements ，所以 方法和类要合为一体生成才行，这是特殊情况
            //生成的类名，entry.getKey()就是组名
            String finalClassName = "ARouter$$Path$$" + entry.getKey();

            // 生成类文件：ARouter$$Path$$组名
            JavaFile.builder(aptPackage, // 包名  APT 存放的路径
                    TypeSpec.classBuilder(finalClassName) // 类名
                            .addSuperinterface(ClassName.get(pathType)) // 实现ARouterPath接口  implements ARouterPath==pathType
                            .addModifiers(Modifier.PUBLIC) // public修饰符
                            .addMethod(methodBuilder.build()) // 方法的构建（方法参数 + 方法体）
                            .build()) // 类构建完成
                    .build() // JavaFile构建完成
                    .writeTo(filer); // 文件生成器开始生成类文件

            // 非常重要一步，注意：PATH 路径文件生成出来了，才能赋值路由组mAllGroupMap
            mAllGroupMap.put(entry.getKey(), finalClassName);
        }
    }

    //生成 Group
    private void createGroupFile(TypeElement groupType, TypeElement pathType)  throws IOException {
        // 判断 map仓库中，是否有需要生成的文件
        if (mAllGroupMap==null||mAllGroupMap.size()==0||mAllPathMap==null||mAllPathMap.size()==0) {
            return;
        }

        // 返回值 这一段 Map<String, Class<? extends ARouterPath>>
        TypeName methodReturns = ParameterizedTypeName.get(
                ClassName.get(Map.class),        // Map
                ClassName.get(String.class),    // Map<String,
                ParameterizedTypeName.get(ClassName.get(Class.class),       // Class<?
                        WildcardTypeName.subtypeOf(ClassName.get(pathType))) // ? extends ARouterPath
        );
        // 1.方法 public Map<String, Class<? extends ARouterPath>> getGroupMap() {
        MethodSpec.Builder methodBuidler = MethodSpec.methodBuilder("getGroupMap") // 方法名
                .addAnnotation(Override.class) // 重写注解 @Override
                .addModifiers(Modifier.PUBLIC) // public修饰符
                .returns(methodReturns); // 方法返回值

        // Map<String, Class<? extends ARouterPath>> groupMap = new HashMap<>();
        methodBuidler.addStatement("$T<$T, $T> $N = new $T<>()",
                ClassName.get(Map.class),
                ClassName.get(String.class),

                // Class<? extends ARouterPath>
                ParameterizedTypeName.get(ClassName.get(Class.class),
                        WildcardTypeName.subtypeOf(ClassName.get(pathType))), // ? extends ARouterPath
                "groupMap",
                ClassName.get(HashMap.class));

        //遍历mAllGroupMap
        for (Map.Entry<String, String> entry : mAllGroupMap.entrySet()) {
            methodBuidler.addStatement("$N.put($S, $T.class)",
                    "groupMap", // groupMap.put
                    entry.getKey(),
                    ClassName.get(aptPackage, entry.getValue()));
        }

        // return groupMap;
        methodBuidler.addStatement("return $N", "groupMap");

        // 最终生成的类文件名 ARouter$$Group$$ + 组名
        String finalClassName = "ARouter$$Group$$" + options;

        messager.printMessage(Diagnostic.Kind.NOTE, "APT生成路由组Group类文件：" +
                aptPackage + "." + finalClassName);

        // 生成类文件：ARouter$$Group$$app
        JavaFile.builder(aptPackage, // 包名
                TypeSpec.classBuilder(finalClassName) // 类名
                        .addSuperinterface(ClassName.get(groupType)) // 实现ARouterGroup接口 implements ARouterGroup
                        .addModifiers(Modifier.PUBLIC) // public修饰符
                        .addMethod(methodBuidler.build()) // 方法的构建（方法参数 + 方法体）
                        .build()) // 类构建完成
                .build() // JavaFile构建完成
                .writeTo(filer); // 文件生成器开始生成类文件
    }


    //验证RouterBean的group和path是否符合要求
    private final boolean checkRouterPath(RouterBean bean){
        String group = bean.getGroup();
        String path = bean.getPath();

        //校验path是否以/开头  例如 /app/MainActivity
        if (path == null || path.length() == 0|| !path.startsWith("/")){
            messager.printMessage(Diagnostic.Kind.ERROR,"必须要以/开头");
            return false;
        }
        //校验path最后一个/不能是开头，也就是不能是/MainActivity
        if (path.lastIndexOf("/") == 0){
            messager.printMessage(Diagnostic.Kind.ERROR,"不符合要求，必须是类似/app/MainActivity");
            return false;
        }

        //截取group
        String finalGroup = path.substring(1,path.indexOf("/",1));
        if (finalGroup == null || finalGroup.length() == 0|| !finalGroup.equals(options)){
            messager.printMessage(Diagnostic.Kind.ERROR,"组名与模块名不一致！！！");
            return false;
        }

        bean.setGroup(finalGroup);
        return true;
    }
}
```
此时大功告成！！

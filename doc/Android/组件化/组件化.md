- [1.什么是组件化](#什么是组件化)
- [2.如何实现不同业务间跳转](#如何实现不同业务间跳转)
- [3.手写类似Arouter](#手写类似Arouter)
- [3.Arouter](#Arouter)

# 什么是组件化
个人理解： 拆分业务，降低耦合，自由拆卸，独立运行

所以不同业务的module之间不能直接通讯，也不能循环依赖

# 如何实现不同业务间跳转
1. 使用EventBus，但是维护成本高，不好管理
2. 使用广播，但是不好管理，都统一发送了
3. 使用隐式跳转，但是注册文件中配置的xml太多
4. 类加载方式，但是容易包名类名写错，相对来说还好
5. 使用全局MAP，但是要注册很多对象

比如现在有两个业务module，它们内部有两个界面A和B，现在要实现A跳转到B

* 针对方式4上代码:
```java
try{
  Class targetClass = Class.forName("com.xxx.modulea.A");
  Intent intent = new Intent(A.this,targetClass);
  startActivity(intent);
}catch(ClassNotFoundException e){}
```
* 针对方式5，需要在业务层下面的基础库中增加一个全局Map，将所有Activity注册进来
```java
//创建一个Path的Bean，存储path和对应的class
public class PathBean{
  private String path;
  private Class clazz;
  
  public PathBean(String path,Class clazz){
    this.path = path;
    this.clazz = clazz;
  }
  
   //省略get和set方法
}

//我们通过path管理器来管理全局的map
public class RecordPathManager{
  //由于不同业务module下可能有多个Activity，所以根据组名保存
  private static Map<String,List<PathBean>> maps = new HashMap<>();
  
  //将Activity注册到全局Map中
  public static void addGroupInfo(String groupName,String path,Class<?> clazz){
    List<PathBean> list = maps.get(groupName);
    
    if(null = list){
      list = new ArrayList<>();
      list.add(new PathBean(path,clazz));
      maps.put(groutName,list);
    }else{
      maps.put(groutName,list);
    }
  }
}

//根据组名和路径得到Class
public static Class<?> startTargetActivity(String groupName,String pathName){
   List<PathBean> list = maps.get(groupName);
    if(null = list){
      return null;
    }
    for (PathBean pathBean : list){
      if(pathName.equalsIgnoreCase(pathBean.getPath())){
        return pathBean.getClazz();
      }
    }
}
```
在Application中将所有Activity注册到Map中，使用时直接通过管理器获取即可，但是问题也和明显，需要在Application中全部注册

# 手写类似Arouter
针对上面的全局Map，Arouter应运而生，其内部也是差不多有个Map来存储，我们可以理解为路由表，但是我们怎么避免手动去注册吗？所以此时我们要用到APT技术，在编译的时候就将Activity注册到路由表中


- [1.什么是热修复](#什么是热修复)
- [2.怎么进行热修复](#怎么进行热修复)
- [3.市面上的热修复方案](#市面上的热修复方案)
- [4.热修复流程](#热修复流程)

#  什么是热修复

在我们应用上线后出现bug需要及时修复时，不用再发新的安装包，只需要发布补丁包，在客户无感知下修复掉bug

# 怎么进行热修复
* 服务端： 补丁包管理
* 客户端： 执行热修复
* 开发端： 生成补丁包

# 市面上的热修复方案
* 即时生效
    * AndFix：在native动态替换java层的方法，通过native层hookjava层的代码，以及在native动态替换java层属性
    * Robust：通过字节码插庄，在编译打包阶段对每个类添加静态属性ChangeQuickRedirect,并对每个函数自动插入一个ChangeQuickRedirect是否为空的开关，如果有补丁则会通过反射技术实例化静态对象并替换，然后执行该方法进入补丁，没有则执行原有逻辑
* 非及时生效
    * Tinker：通过计算对比指定的Base Apk的dex与修改后的Apk中的dex区别，补丁包中的内容即为两者差分描述，运行时将Base Apk中的dex与补丁包进行合成，重启后加载全新的合成后的dex文件(主要通过bsdiff进行增量更新，通过bsdiff工具生成两个Apk的dex差分patch，然后再通过bspatch工具将旧的dex与差分patch生成新的dex，之后通过类加载机制反射替换即可) 
    * QZone：直接打包成新的差分patch.dex，通过类加载机制添加到dexElements数组最前面即可

# 热修复流程
![image](https://user-images.githubusercontent.com/61224872/115345117-e617d580-a1e0-11eb-898b-051b6990e0a5.png)
* 获取到当前应用的PathClassloader
* 反射获取到DexPathList属性对象pathList
* 反射修改pathList的dexElements
    * 把补丁包patch.dex转化为Element[]
    * 获得旧包的pathList的dexElements属性
    * patch+dexElements合并，并反射赋值给pathList的dexElements

注意： 越早执行越好，因为在ClassLoader里如果加载过了就会从缓存中直接拿取，所以如果加载过了就无法加载新的了

完整流程：

1. 制作补丁包
    1. 修复BUG！！
    2. 重新build项目
    3. 执行dx --dex--output=patch.jar xxx/xxx/xxx/xxx.class(这个class就是刚才build过后生成的修复类的class文件)   
2. 使用补丁包([组件化](../组件化/组件化.md)有具体代码，唯一的不同是热修复会将补丁包数组置前)
    1. 获取程序的PathClassLoader对象
    2. 反射获得PathClassLoader父类BaseDexClassLoader的pathList对象
    3. 反射获取pathList的dexElements对象 （oldElement）
    4. 把补丁包变成Element数组：patchElement（反射执行makePathElements）
    5. 合并patchElement+oldElement = newElement （Array.newInstance）
    6. 反射把oldElement赋值成newElement

代码实现：
```java
//先来个查找属性的工具方法
public static Field findField(Object instance, String name) throws NoSuchFieldException {
        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
            try {
                //查找当前类的 属性(不包括父类)
                Field field = clazz.getDeclaredField(name);

                if (!field.isAccessible()) {
                    field.setAccessible(true);
                }
                return field;
            } catch (NoSuchFieldException e) {
                // ignore and search next
            }
        }
        throw new NoSuchFieldException("Field " + name + " not found in " + instance.getClass());
}

public static void installPatch(Application application, File patch) {
        if (patch.exists()) {
            patchs.add(patch);
        }

        //1、获取程序的PathClassLoader对象
        ClassLoader classLoader = application.getClassLoader();
        //2、反射获得PathClassLoader父类BaseDexClassLoader的pathList对象
        try {
            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
            Object pathList = pathListField.get(classLoader);
            //3、反射获取pathList的dexElements对象 （oldElement）
            Field dexElementsField = findField(pathList, "dexElements");
            Object[] oldElements = (Object[]) dexElementsField.get(pathList);
            //4、把补丁包变成Element数组：patchElement（反射执行makePathElements）
            Object[] patchElements = null;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                Method makePathElements = findMethod(pathList, "makePathElements",
                        List.class, File.class,
                        List.class);
                ArrayList<IOException> ioExceptions = new ArrayList<>();
                patchElements = (Object[])
                        makePathElements.invoke(pathList, patchs, application.getCacheDir(), ioExceptions);

            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                Method makePathElements = ShareReflectUtil.findMethod(pathList, "makeDexElements",
                        ArrayList.class, File.class, ArrayList.class);
                ArrayList<IOException> ioExceptions = new ArrayList<>();
                patchElements = (Object[])
                        makePathElements.invoke(pathList, patchs, application.getCacheDir(), ioExceptions);
            }


            //5、合并patchElement+oldElement = newElement （Array.newInstance）
            //创建一个新数组，大小 oldElements+patchElements
            Object[] newElements = (Object[]) Array.newInstance(oldElements.getClass().getComponentType(),
                    oldElements.length + patchElements.length);

            System.arraycopy(patchElements, 0, newElements, 0, patchElements.length);
            System.arraycopy(oldElements, 0, newElements, patchElements.length, oldElements.length);
            //6、反射把oldElement赋值成newElement
            dexElementsField.set(pathList, newElements);
        } catch (Exception e) {
            e.printStackTrace();
        }
}
```

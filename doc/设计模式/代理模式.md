- [1.什么是代理模式](#什么是代理模式)
- [2.代理模式的好处](#代理模式的好处)
- [3.代理模式的三个角色](#代理模式的三个角色)
- [4.静态代理](#静态代理)
- [5.动态代理](#动态代理)

# 什么是代理模式

代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。将使用者与真实对象进行隔离，通俗的来讲代理模式就是我们生活中常见的中介。

# 代理模式的好处

1. 通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性
2. 通过代理对象对访问进行控制

# 代理模式的三个角色
![image](https://user-images.githubusercontent.com/61224872/111108734-6a4cbc80-8594-11eb-9bf1-a8bfc073a656.png)

1. 抽象角色: 指代理角色和真实角色对外提供的公共方法，一般为一个接口
2. 真实角色: 需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业务逻辑在此
3. 代理角色: 需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理

# 静态代理

* 使用:
1. 抽象角色: Sale，公共方法sale()
```java
public interface Sale {
    void sale();
}
```
2. 真实角色: 实现抽象接口，并打印sale()
```java
public class CompanyA implements Sale{
    @Override
    public void sale() {
        System.out.println("CompanyA sale");
    }
}
```
3. 代理角色: 实现抽象接口，并在抽象方法中的实际业务前后添加自己的操作
```java
public class Agent implements Sale{
    private Sale sale;

    public Agent(Sale sale) {
        this.sale = sale;
    }
    
    private void before(){
        System.out.println("before");
    }

    private void after(){
        System.out.println("after");
    }

    @Override
    public void sale() {
        before();
        sale.sale();
        after();
    }
}
```
4. 使用
```java
//创建真实对象
Sale sale = new CompanyA();
//创建代理对象，并将代理对象与真实对象绑定
Agent agent = new Agent(sale);
//通过代理对象使用sale()，避免直接使用真实对象
agent.sale();
```
可以看到代理模式在于控制，代理对象会将真实的sale交个真实对象来处理，而它主要负责控制

* 应用场景:

  比如我们在早起开发中使用网络模块的Volley，但是之后改为了Okhttp，或者说从百度地图切换到了高德地图，如果我们没有很好地架构设计这块，那么我们切换的时候就要到处改，而如果使用了代理模式，则直接可以通过切换代理对象中的真实对象即可。相当于是将实际使用与框架层中间做了一层隔离。

* 问题

  如果真实对象不光实现了抽象角色，还有其他的抽象角色，这时候之前的代理对象就不能满足，还需要新的代理对象来满足新的抽象角色，比如上面的demo中又来个ComanyB，他不光有sale，还有buy，此时就要新建一个buy的代理类。这样就会在程序中产生很多的代理类，所以此时就需要一个代理类实现全部的代理功能----动态代理
  
  
# 动态代理
* 使用:
```java
public interface Sale {
    void sale();
}
public interface Buy {
    void buy();
}
public class CompanyA implements Sale{
    @Override
    public void sale() {
        System.out.println("CompanyA sale");
    }
}
public class CompanyB implements Sale,Buy{
    @Override
    public void sale() {
        System.out.println("CompanyB sale");
    }
    @Override
    public void buy() {
        System.out.println("CompanyB buy");
    }
}

public static void main(String[] args) {
   //创建真实对象
   CompanyB companyB = new CompanyB();
   
   //通过动态代理代理对象
   //第一个参数类加载器
   //第二个参数是需要代理的接口数组
   //第三个参数是InvocationHandler，他会通过对象o调用接口方法的时候回调到自己的invoke函数中
   Object o = Proxy.newProxyInstance(Test.class.getClassLoader(),new Class[]{Sale.class,Buy.class},
                new InvocationHandler(){
                    @Override   // Object o就是代理对象o，Method就是我们调用的方法，Object[]就是方法参数
                    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
                        //通过反射调用代理对象的对应方法，等于我们代理的是companyB
                        return method.invoke(companyB,objects);
                    }
  });
  
  //o既能代理Sale接口，也能代理Buy接口
  Sale sale1 = (Sale) o;
  
  //此时调用sale，会进入到代理对象中InvocationHandler的invoke函数中
  ((Sale) o).sale();
}
```

* 注意

如果在invoke函数中打印o对象，则会报出栈溢出错误，原因是打印o，相当于是调用了o的toString(),这就相当于一个无限循环



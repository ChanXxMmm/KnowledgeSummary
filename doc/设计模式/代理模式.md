- [1.什么是代理模式](#什么是代理模式)
- [2.代理模式的好处](#代理模式的好处)
- [3.代理模式的三个角色](#代理模式的三个角色)
- [4.静态代理](#静态代理)
- [5.动态代理](#动态代理)
- [6.Proxy.newProxyInstance解析](#Proxy.newProxyInstance解析)
# 什么是代理模式

代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。将使用者与真实对象进行隔离，通俗的来讲代理模式就是我们生活中常见的中介。

# 代理模式的好处

1. 通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性
2. 通过代理对象对访问进行控制

# 代理模式的三个角色
![image](https://user-images.githubusercontent.com/61224872/111108734-6a4cbc80-8594-11eb-9bf1-a8bfc073a656.png)

1. 抽象角色: 指代理角色和真实角色对外提供的公共方法，一般为一个接口
2. 真实角色: 需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业务逻辑在此
3. 代理角色: 需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理

# 静态代理

* 使用:
1. 抽象角色: Sale，公共方法sale()
```java
public interface Sale {
    void sale();
}
```
2. 真实角色: 实现抽象接口，并打印sale()
```java
public class CompanyA implements Sale{
    @Override
    public void sale() {
        System.out.println("CompanyA sale");
    }
}
```
3. 代理角色: 实现抽象接口，并在抽象方法中的实际业务前后添加自己的操作
```java
public class Agent implements Sale{
    private Sale sale;

    public Agent(Sale sale) {
        this.sale = sale;
    }
    
    private void before(){
        System.out.println("before");
    }

    private void after(){
        System.out.println("after");
    }

    @Override
    public void sale() {
        before();
        sale.sale();
        after();
    }
}
```
4. 使用
```java
//创建真实对象
Sale sale = new CompanyA();
//创建代理对象，并将代理对象与真实对象绑定
Agent agent = new Agent(sale);
//通过代理对象使用sale()，避免直接使用真实对象
agent.sale();
```
可以看到代理模式在于控制，代理对象会将真实的sale交个真实对象来处理，而它主要负责控制

* 应用场景:

  比如我们在早起开发中使用网络模块的Volley，但是之后改为了Okhttp，或者说从百度地图切换到了高德地图，如果我们没有很好地架构设计这块，那么我们切换的时候就要到处改，而如果使用了代理模式，则直接可以通过切换代理对象中的真实对象即可。相当于是将实际使用与框架层中间做了一层隔离。

* 问题

  如果真实对象不光实现了抽象角色，还有其他的抽象角色，这时候之前的代理对象就不能满足，还需要新的代理对象来满足新的抽象角色，比如上面的demo中又来个ComanyB，他不光有sale，还有buy，此时就要新建一个buy的代理类。这样就会在程序中产生很多的代理类，所以此时就需要一个代理类实现全部的代理功能----动态代理
  
  
# 动态代理
* 使用:
```java
public interface Sale {
    void sale();
}
public interface Buy {
    void buy();
}
public class CompanyA implements Sale{
    @Override
    public void sale() {
        System.out.println("CompanyA sale");
    }
}
public class CompanyB implements Sale,Buy{
    @Override
    public void sale() {
        System.out.println("CompanyB sale");
    }
    @Override
    public void buy() {
        System.out.println("CompanyB buy");
    }
}

public static void main(String[] args) {
   //创建真实对象
   CompanyB companyB = new CompanyB();
   
   //通过动态代理代理对象
   //第一个参数类加载器
   //第二个参数是需要代理的接口数组
   //第三个参数是InvocationHandler，他会在对象o调用任何它的方法的时候回调到invoke函数中，等于调用companyB的任何方法都会进来
   Object o = Proxy.newProxyInstance(Test.class.getClassLoader(),new Class[]{Sale.class,Buy.class},
                new InvocationHandler(){
                    @Override   // Object o就是代理对象o，Method就是我们调用的方法，Object[]就是方法参数
                    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
                        //通过反射调用代理对象的对应方法，等于我们代理的是companyB
                        return method.invoke(companyB,objects);
                    }
  });
  
  //o既能代理Sale接口，也能代理Buy接口
  Sale sale1 = (Sale) o;
  
  //此时调用sale，会进入到代理对象中InvocationHandler的invoke函数中
  ((Sale) o).sale();
}
```

* 注意

如果在invoke函数中打印o对象，则会报出栈溢出错误，原因是打印o，相当于是调用了o的toString(),这就相当于一个无限循环

# Proxy.newProxyInstance解析

```java
 public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        //1.因为动态代理代理的都是接口，所以对接口进行一次拷贝
        final Class<?>[] intfs = interfaces.clone();
        
        //2.获取缓存中是否有创建过的该代理class，有则取，无则通过ProxyClassFactory创建
        Class<?> cl = getProxyClass0(loader, intfs);

        try {
            //3.获取创建的代理class的构造方法
            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                cons.setAccessible(true);
            }
            //4.通过构造方法创建实例，并将InvocationHandler传入
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
```
创建ProxyClassFactory的操作其实就是通过generateProxy进行字节码操作，我们这里不做详细介绍，知道就行了

而我们此时可以通过一段代码将创建的class保存到本地查看
```java
private static void proxy() throws Exception{
        String name = Sale.class.getName() + "$Proxy0";

        byte[] bytes = ProxyGenerator.generateProxyClass(name,new Class[]{Sale.class});
        FileOutputStream fos = new FileOutputStream("lib/"+name+".class");
        fos.write(bytes);
        fos.close();
}
```
调用上面代码会在我们的项目中出现一个包名.Sale$Proxy0.class的文件，双击打开
```java
public final class Sale$Proxy0 extends Proxy implements Sale {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    public Sale$Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void sale() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m3 = Class.forName("包名.Sale").getMethod("sale");
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```
可以看到几个重要的东西:
1. 构造方法: 它会接收一个InvocationHandler，也就是我们创建代理对象的时候传入的，它会将该对象给到父类，也就是Proxy，保存到h中
2. sale方法: 它会通过上面保存的InvocationHandler对象，调用它的invoke函数进行回调，参数1就是本身，参数2是在生成的静态块中通过反射获取到的接口中方法对象，参数3就是方法的参数
3. toString方法: 我们之前提到过在invoke中打印o，会循环，是因为在代理class中的toString也会回调invoke函数

总结: 
1. 将接口进行一次拷贝
2. 创建代理class类，内部会通过构造方法接收InvocationHandler并保存
3. 通过反射得到代理class类的构造方法
4. 通过代理class类的构造方法创建代理对象，同时调用代理class类的构造方法
5. 这时候如果调用代理对象的任何方法，都会进入到代理class类的方法中，通过InvocationHandler的invoke函数进行回调

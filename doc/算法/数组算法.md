- [1480一维数组的动态和](#1480一维数组的动态和)
- [1672最富有客户的资产总量](#1672最富有客户的资产总量)
- [1512好数对的数目](#1512好数对的数目)
- [1431拥有最多糖果的孩子](#1431拥有最多糖果的孩子)
- [1470重新排列数组](#1470重新排列数组)
- [1773统计匹配检索规则的物品数量](#1773统计匹配检索规则的物品数量)
- [1486数组异或操作](#1486数组异或操作)
- [1313解压缩编码列表](#1313解压缩编码列表)

# 1480一维数组的动态和
题目: 给你一个数组 nums，数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i])，请返回 nums 的动态和。
```java
示例 1：
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。

示例 2：
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。

示例 3：
输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
```
解答:
```java
class Solution {
    public int[] runningSum(int[] nums) {
        for(int i = 1;i < nums.length;i++){
            nums[i] += nums[i-1];
        }
        return nums;
    }
}
```

# 1672最富有客户的资产总量
题目: 给你一个 m x n 的整数网格accounts,其中 accounts[i][j] 是第 i​​​​​​​​​​​​ 位客户在第j家银行托管的资产数量。返回最富有客户所拥有的资产总量。客户的资产总量就是他们在各家银行托管的资产数量之和。最富有客户就是资产总量最大的客户。
```java
示例 1：
输入：accounts = [[1,2,3],[3,2,1]]
输出：6
解释：
第 1 位客户的资产总量 = 1 + 2 + 3 = 6
第 2 位客户的资产总量 = 3 + 2 + 1 = 6
两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。

示例 2：
输入：accounts = [[1,5],[7,3],[3,5]]
输出：10
解释：
第 1 位客户的资产总量 = 6
第 2 位客户的资产总量 = 10 
第 3 位客户的资产总量 = 8
第 2 位客户是最富有的，资产总量是 10

示例 3：
输入：accounts = [[2,8,7],[7,1,3],[1,9,5]]
输出：17
```
解答:
```java
class Solution {
    public int maximumWealth(int[][] accounts) {
        int max = 0;
        for(int i = 0;i<accounts.length;i++){
            int temp = 0;
            for(int j = 0;j<accounts[i].length;j++){
                temp +=accounts[i][j];
            }
            max = Math.max(max,temp);
        }
        return max;
    }
}
```

# 1512好数对的数目
题目: 给你一个整数数组 nums 。如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 。返回好数对的数目。
```java
示例 1：
输入：nums = [1,2,3,1,1,3]
输出：4
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始

示例 2：
输入：nums = [1,1,1,1]
输出：6
解释：数组中的每组数字都是好数对

示例 3：
输入：nums = [1,2,3]
输出：0
```
解答:
```java
class Solution {
    public int numIdenticalPairs(int[] nums) {
        int ans = 0;
        int[] temp = new int[100];
        for (int num : nums) {
                  ans += temp[num - 1]++;
        }
        return ans;
    }
}
```

# 1431拥有最多糖果的孩子
题目: 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。
```java
示例 1：
输入：candies = [2,3,5,1,3], extraCandies = 3
输出：[true,true,true,false,true] 
解释：
孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。

示例 2：
输入：candies = [4,2,1,1,2], extraCandies = 1
输出：[true,false,false,false,false] 
解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。

示例 3：
输入：candies = [12,1,12], extraCandies = 10
输出：[true,false,true]
``` 
解答:
```java
class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List list = new ArrayList<Boolean>(candies.length);
        int max = 0;
        for (int i = 0; i < candies.length; i++) {
            if (candies[i] > max) {
                max = candies[i];
            }
        }
        for (int j = 0; j < candies.length; j++) {
            if (candies[j] + extraCandies >= max) {
                list.add(true);
            } else {
                list.add(false);
            }
        }
        return list;
    }
}
```

# 1470重新排列数组
题目:给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。
```java
示例 1：
输入：nums = [2,5,1,3,4,7], n = 3
输出：[2,3,5,4,1,7] 
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]

示例 2：
输入：nums = [1,2,3,4,4,3,2,1], n = 4
输出：[1,4,2,3,3,2,4,1]

示例 3：
输入：nums = [1,1,2,2], n = 2
输出：[1,2,1,2]
```
解答:
```java
class Solution {
    public int[] shuffle(int[] nums, int n) {

		 int[] arry = new int[nums.length];
		 
		 int j =0; 
		 
		 for(int i = 0 ; i < nums.length/2 ; i++){
			 arry[j++] = nums[i];  
			 
			 arry[j++] = nums[n +i]; 
		 }
		
		return arry;

    }
}
```

# 1773统计匹配检索规则的物品数量
题目: 给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。
```java
如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：
ruleKey == "type" 且 ruleValue == typei 。
ruleKey == "color" 且 ruleValue == colori 。
ruleKey == "name" 且 ruleValue == namei 。
统计并返回 匹配检索规则的物品数量 。

示例 1：
输入：items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
输出：1
解释：只有一件物品匹配检索规则，这件物品是 ["computer","silver","lenovo"] 。

示例 2：
输入：items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
输出：2
解释：只有两件物品匹配检索规则，这两件物品分别是 ["phone","blue","pixel"] 和 ["phone","gold","iphone"] 。注意，["computer","silver","phone"] 未匹配检索规则。
```
解答:
```java
class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int res = 0;
        int k = ruleKey.equals("type")?0:ruleKey.equals("color")?1:2;
        for (List<String> l : items)
            if (l.get(k).equals(ruleValue)) res++;
        return res;    
            
    }
}
```

# 1486数组异或操作
题目: 给你两个整数，n 和 start 。数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。请返回 nums 中所有元素按位异或（XOR）后得到的结果。
```java
示例 1：
输入：n = 5, start = 0
输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     "^" 为按位异或 XOR 运算符。
     
示例 2：
输入：n = 4, start = 3
输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.

示例 3：
输入：n = 1, start = 7
输出：7

示例 4：
输入：n = 10, start = 5
输出：2
```
解答: 
```java
class Solution {
    public int xorOperation(int n, int start) {
        int sum = 0;
        for(int i=0;i<n;i++){
            sum ^= start + 2*i;
        }
         return sum;

    }
}
```

#  1313解压缩编码列表
题目:给你一个以行程长度编码压缩的整数列表 nums 。考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。请你返回解压后的列表。
```java
示例 1：
输入：nums = [1,2,3,4]
输出：[2,4,4,4]
解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。

示例 2：
输入：nums = [1,1,2,3]
输出：[1,3,3]
```
解答:
```java
class Solution {
    public int[] decompressRLElist(int[] nums) {
        int len = nums.length;
        int newLength = 0;
        // 偶数位相加即为新数组长度
        for (int i = 0; i < len; i+=2){
            newLength += nums[i];
        }
        int[] result = new int[newLength];
        // 新数组角标
        int index = 0;
        for(int i = 0; i < len; i+=2){
            // 填充a个b,每填充一次,a-1,index+1
            int a = nums[i];
            while(a > 0){
                result[index] = nums[i+1];
                a--;
                index++;
            }
        }
        return result;
    }
}
```

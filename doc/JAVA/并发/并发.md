- [1.基础概念](#基础概念)
- [2.线程](#线程)
- [3.线程的生命周期](#线程的生命周期)

# 基础概念
* 什么是进程和线程
  * 进程是程序运行资源分配的最小单位
  * 线程是CPU调度的最小单位,必须依赖于进程而存在

* CPU时间片轮转机制(RR调度)
  * 每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。
  * 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾 
  * 进程切换也叫上下文切换，很耗费CPU时间，所以尽量避免上下文切换
  * 时间片设得太短会导致过多的进程切换,降低了CPU效率: 而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。

* 高并发编程
  * 意义: 由于多核多线程的CPU的诞生,多线程和高并发的编程越来越受重视和关注 
  * 好处:
    * 充分利用CPU资源: 在多核CPU下，只有多线程才能充分利用CPU资源
    * 加快响应用户的时间: 多个线程比单线程速度要快
    * 可以使代码模块化，异步化和简单化: 比如多步骤情况下，避免单线程增加等待时间，使用多线程，异步执行
  * 注意事项:
    * 安全性: 由于线程之间共享进程资源，肯定就会存在争夺等问题，这就是线程安全问题
    * 线程之间的锁问题: 为了解决安全问题引入了锁，但是会产生死锁，也会产生锁竞争导致性能下降，没准还不如单线程速度快
    * 线程过多: 线程的数量是有限的，不是无穷无尽的，由操作系统限制，线程过多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机，所以可以使用线程池

# 线程
Java里的程序天生就是多线程的，一个Java程序都要从main()方法开始，它就是我们常说的main线程，同时还会启动很多其他线程

* 线程的启动与中止
  * 线程的启动方式
    * 继承扩展Thread类，重写run方法
    * 实现Runnable接口，实现run方法
    * Thread和Runnable的区别: Thread是线程的抽象，Runnable是任务的抽象
  * 线程的停止
    * stop(): 强制停止线程，不会关心资源是否释放，不建议使用
    * suspend(): 将线程挂起，强制进行上下文切换，但是不会关心资源是否释放，不建议使用
    * interrupt(): 将线程中断，但只是改变一个中断标志位，未必会中断，要配合isInterrupted()使用(当线程睡眠中被中断，会抛出中断异常，同时重置标志位，需要在异常中修改标志位)
    * isInterrupted(): 返回线程是否被中断
    * interrupted(): 静态方法，返回线程是否被中断，但是会将标志位重置
  * 线程start与run区别:
    * start: 将线程加入到CPU时间片轮转机制的进程列表中等待分配执行
    * run: 只是在调用run方法的线程里执行这个任务而已

# 线程的生命周期
![image](https://user-images.githubusercontent.com/61224872/111950142-dabb8680-8b1c-11eb-9fec-c59c80d32c8c.png)


* 新建: new Thread(),此时还是一个类的实例
* 新建-就绪: 当调用start()后，线程进入就绪状态
* 就绪-运行: 
  * 当时间片轮转分配该线程时间片后 该线程才进入到运行状态
  * join(): 调用join()后，该线程才进入到运行状态，
* 运行-就绪: 
  * 时间片到期，该线程进入到就绪状态
  * yield(): 调用yield()后让出时间片，该线程进入到就绪状态，不释放锁
* 运行-死亡:
  * 线程跑完了，该线程进入到死亡状态
  * stop(): 调用stop()后，该线程进入到死亡状态
  * setDeamon(): 设置为守护线程，当线程所在的进程中所有非守护线程(用户线程)死亡后，该线程会进入到死亡状态，它内部的finally不一定起作用，比如垃圾回收器线程
* 运行-阻塞:
  * sleep(): sleep()后，该线程进入到阻塞状态，将线程挂起不再进行分配cpu和资源，不释放锁
  * wait(): wait()后，线程进入到阻塞状态，释放锁
* 阻塞-就绪:
  * sleep时间到: 当sleep时间到期后，线程被唤醒进入到就绪状态
  * notify()/notifyAll(): 当其他线程调用notify()/notifyAll()后，通知该线程进入到就绪状态，准备重新抢夺锁
  * interrupt(): 线程抛出中断异常，该线程从睡眠进入到就绪状态
* 线程的优先级:
```java
new Thread().setPriority(5);
```
线程优先级从1-10，默认为5，值越大表明越可能分配的时间片多，取决于底层




- [1.基础概念](#基础概念)
- [2.线程](#线程)
- [3.线程的生命周期](#线程的生命周期)
- [4.线程间的共享](#线程间的共享)
  - [synchronized内置锁](#synchronized内置锁)
  - [volatile](#volatile)
  - [ThreadLocal](#ThreadLocal)

# 基础概念
* 什么是进程和线程
  * 进程是程序运行资源分配的最小单位
  * 线程是CPU调度的最小单位,必须依赖于进程而存在

* CPU时间片轮转机制(RR调度)
  * 每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。
  * 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾 
  * 进程切换也叫上下文切换，很耗费CPU时间，所以尽量避免上下文切换
  * 时间片设得太短会导致过多的进程切换,降低了CPU效率: 而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。

* 高并发编程
  * 意义: 由于多核多线程的CPU的诞生,多线程和高并发的编程越来越受重视和关注 
  * 好处:
    * 充分利用CPU资源: 在多核CPU下，只有多线程才能充分利用CPU资源
    * 加快响应用户的时间: 多个线程比单线程速度要快
    * 可以使代码模块化，异步化和简单化: 比如多步骤情况下，避免单线程增加等待时间，使用多线程，异步执行
  * 注意事项:
    * 安全性: 由于线程之间共享进程资源，肯定就会存在争夺等问题，这就是线程安全问题
    * 线程之间的锁问题: 为了解决安全问题引入了锁，但是会产生死锁，也会产生锁竞争导致性能下降，没准还不如单线程速度快
    * 线程过多: 线程的数量是有限的，不是无穷无尽的，由操作系统限制，线程过多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机，所以可以使用线程池

# 线程
Java里的程序天生就是多线程的，一个Java程序都要从main()方法开始，它就是我们常说的main线程，同时还会启动很多其他线程

* 线程的启动与中止
  * 线程的启动方式
    * 继承扩展Thread类，重写run方法
    * 实现Runnable接口，实现run方法
    * Thread和Runnable的区别: Thread是线程的抽象，Runnable是任务的抽象
  * 线程的停止
    * stop(): 强制停止线程，不会关心资源是否释放，不建议使用
    * suspend(): 将线程挂起，强制进行上下文切换，但是不会关心资源是否释放，不建议使用
    * interrupt(): 将线程中断，但只是改变一个中断标志位，未必会中断，要配合isInterrupted()使用(当线程睡眠中被中断，会抛出中断异常，同时重置标志位，需要在异常中修改标志位)
    * isInterrupted(): 返回线程是否被中断
    * interrupted(): 静态方法，返回线程是否被中断，但是会将标志位重置
  * 线程start与run区别:
    * start: 将线程加入到CPU时间片轮转机制的进程列表中等待分配执行
    * run: 只是在调用run方法的线程里执行这个任务而已

# 线程的生命周期
![image](https://user-images.githubusercontent.com/61224872/111950142-dabb8680-8b1c-11eb-9fec-c59c80d32c8c.png)


* 新建: new Thread(),此时还是一个类的实例
* 新建-就绪: 当调用start()后，线程进入就绪状态
* 就绪-运行: 
  * 当时间片轮转分配该线程时间片后 该线程才进入到运行状态
  * join(): 调用join()后，该线程才进入到运行状态，
* 运行-就绪: 
  * 时间片到期，该线程进入到就绪状态
  * yield(): 调用yield()后让出时间片，该线程进入到就绪状态，不释放锁
* 运行-死亡:
  * 线程跑完了，该线程进入到死亡状态
  * stop(): 调用stop()后，该线程进入到死亡状态
  * setDeamon(): 设置为守护线程，当线程所在的进程中所有非守护线程(用户线程)死亡后，该线程会进入到死亡状态，它内部的finally不一定起作用，比如垃圾回收器线程，主要是调度工作
* 运行-阻塞:
  * sleep(): sleep()后，该线程进入到阻塞状态，将线程挂起不再进行分配cpu和资源，不释放锁
  * wait(): wait()后，线程进入到阻塞状态，释放锁
* 阻塞-就绪:
  * sleep时间到: 当sleep时间到期后，线程被唤醒进入到就绪状态
  * notify()/notifyAll(): 当其他线程调用notify()/notifyAll()后，通知该线程进入到就绪状态，准备重新抢夺锁
  * interrupt(): 线程抛出中断异常，该线程从睡眠进入到就绪状态
* 线程的优先级:
```java
new Thread().setPriority(5);
```
线程优先级从1-10，默认为5，值越大表明越可能分配的时间片多，取决于底层

# 线程间的共享 
多个线程访问同一个资源，如果不作任何控制，则会出现线程同步问题或者线程不安全问题

# synchronized内置锁
保证在某一时刻，只有一个线程访问同一个资源，保证了可见性和原子性

*对象锁
  * 对同步块加锁
  ```java
  private Object obj = new Object();
  public void method(){
    synchronized(obj){  //与synchronized(this)相同，不过前者是锁obj对象，后者是锁该类的对象
      //doSomething
    }
  }
  ```
  * 对方法加锁
  ```java
  public synchronized void method(){//等同于synchronized(this)
      //doSomething
  }
  ```
* 类锁: 静态方法上,等于是锁的类的Class
```java
private static Object obj = new Object();
private static void method(){
  synchronized(obj){//锁的是Object.class
   //doSomething
  }
}
```
注意: 如果锁的是常量，比如int类型的常量，在锁内部对它进行i++,则会导致错误的加锁，因为i++会创建新的对象，导致锁的不是一个对象，所以用sychronized加锁时要保证对象不会变化

* synchronized原理


# volatile
volatile关键字，最轻量的同步机制，它只保证可见性，所以适用于一写多读的场景 

* volatile原理

# ThreadLocal
为每一个线程提供了一个变量副本，这就形成了线程隔离

* ThreadLocal使用:
```java
private ThreadLocal<Integer> threadlocal = new ThreadLocal<Integer>(){
  @Override
  protected Integer initialValue(){
    return 1;//返回默认值
  }
}
Integer i = threadlocal.get()
i = i++;
threadlocal.set(i);
```

* ThreadLocal解析
```java
//Thread.class
//每个线程中有一个ThreadLocal.ThreadLocalMap的成员变量
ThreadLocal.ThreadLocalMap threadLocals = null;


//ThreadLocal.class
static class ThreadLocalMap {
        static class Entry extends WeakReference<ThreadLocal<?>> {
            Object value;
            
            //以不同泛型的具体类型的ThreadLocal为key，以存的值为value
            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
        
        //由于Entry的key是泛型的ThreadLocal，所以一个线程中可以有多个类型的ThreadLocal存在数组中
        private Entry[] table;
         
        //......
}

//ThreadLocal.class
public T get() {
        //1.拿到调用该方法所在的线程
        Thread t = Thread.currentThread();

        //2.通过线程t拿到该线程独有的ThreadLocalMap
        ThreadLocalMap map = getMap(t);
        
        //如果map不为空，以ThreadLocal为key去拿value
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        //如果map为空或者map中没有，则创建一个以默认值为value的Entry保存到map中并返回
        return setInitialValue();
}

```

* 引发内存泄漏的原因
```java
//ThreadLocalMap
 static class Entry extends WeakReference<ThreadLocal<?>> 
```
我们知道ThreadLocalMap中的Entry是用的弱引用(对对象的引用不了解可以去[JVM](./doc/JVM/JVM.md)中对象的引用学习),
